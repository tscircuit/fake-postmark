This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    bun-build.yml
    bun-pver-release.yml
    bun-test.yml
    bun-typecheck.yml
lib/
  db/
    db-client.ts
    schema.ts
  middleware/
    with-db.ts
    with-winter-spec.ts
pages/
  api/
    [[...route]].ts
routes/
  things/
    create.ts
    list.ts
  v1/
    messages/
      index.ts
  health.ts
tests/
  fixtures/
    get-test-server.ts
    normalizeForSnapshot.ts
    start-server.ts
  routes/
    things/
      create.test.ts
    health.test.ts
  usage/
    usage1-anthropic-sdk.test.ts
.gitignore
biome.json
next-env.d.ts
package.json
README.md
tsconfig.json
winterspec.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/bun-build.yml">
# Created using @tscircuit/plop (npm install -g @tscircuit/plop)
name: Build

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Run build
        run: bun run build
</file>

<file path=".github/workflows/bun-pver-release.yml">
# Created using @tscircuit/plop (npm install -g @tscircuit/plop)
name: Publish to npm
on:
  push:
    branches:
      - main
jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest
      - uses: actions/setup-node@v3
        with:
          node-version: 20
          registry-url: https://registry.npmjs.org/
      - run: npm install -g pver
      - run: bun install --frozen-lockfile
      - run: bun run build
      - run: pver release
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
</file>

<file path=".github/workflows/bun-test.yml">
# Created using @tscircuit/plop (npm install -g @tscircuit/plop)
name: Bun Test

on:
  pull_request:

jobs:
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Setup bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Run tests
        run: bun test
</file>

<file path=".github/workflows/bun-typecheck.yml">
# Created using @tscircuit/plop (npm install -g @tscircuit/plop)
name: Type Check

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  type-check:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun i

      - name: Build before type checking (code uses dist/bundle)
        run: bun run build

      - name: Run type check
        run: bunx tsc --noEmit
</file>

<file path="lib/db/db-client.ts">
import { createStore, type StoreApi } from "zustand/vanilla"
import { hoist, type HoistedStoreApi } from "zustand-hoist"

import { databaseSchema, type DatabaseSchema, type Thing } from "./schema.ts"
import { combine } from "zustand/middleware"

export const createDatabase = () => {
  return hoist(createStore(initializer))
}

export type DbClient = ReturnType<typeof createDatabase>

const initializer = combine(databaseSchema.parse({}), (set) => ({
  addThing: (thing: Omit<Thing, "thing_id">) => {
    set((state) => ({
      things: [
        ...state.things,
        { ...thing, thing_id: state.idCounter.toString() },
      ],
      idCounter: state.idCounter + 1,
    }))
  },
}))
</file>

<file path="lib/db/schema.ts">
import { z } from "zod"

// When defining your database schema, try to use snake case for column names.

export const thingSchema = z.object({
  thing_id: z.string(),
  name: z.string(),
  description: z.string(),
})
export type Thing = z.infer<typeof thingSchema>

export const databaseSchema = z.object({
  idCounter: z.number().default(0),
  things: z.array(thingSchema).default([]),
})
export type DatabaseSchema = z.infer<typeof databaseSchema>
</file>

<file path="lib/middleware/with-db.ts">
import type { DbClient } from "lib/db/db-client"
import { createDatabase } from "lib/db/db-client"
import type { Middleware } from "winterspec"

export const withDb: Middleware<
  {},
  {
    db: DbClient
  }
> = async (req, ctx, next) => {
  if (!ctx.db) {
    ctx.db = createDatabase()
  }
  return next(req, ctx)
}
</file>

<file path="lib/middleware/with-winter-spec.ts">
import { createWithWinterSpec } from "winterspec"
import { withDb } from "./with-db"

export const withRouteSpec = createWithWinterSpec({
  apiName: "tscircuit Debug API",
  productionServerUrl: "https://debug-api.tscircuit.com",
  beforeAuthMiddleware: [],
  authMiddleware: {},
  afterAuthMiddleware: [withDb],
})
</file>

<file path="pages/api/[[...route]].ts">
import bundle from "dist/bundle"
import { getNodeHandler } from "winterspec/adapters/node"

const handler = getNodeHandler(bundle as any, {})

export default (req: any, res: any) => handler(req, res)
</file>

<file path="routes/things/create.ts">
import { withRouteSpec } from "lib/middleware/with-winter-spec"
import { z } from "zod"

export default withRouteSpec({
  methods: ["POST"],
  jsonBody: z.object({
    name: z.string(),
    description: z.string(),
  }),
  jsonResponse: z.object({
    ok: z.boolean(),
  }),
})(async (req, ctx) => {
  const { name, description } = await req.json()
  ctx.db.addThing({
    name,
    description,
  })
  return ctx.json({ ok: true })
})
</file>

<file path="routes/things/list.ts">
import { withRouteSpec } from "lib/middleware/with-winter-spec"
import { z } from "zod"

export default withRouteSpec({
  methods: ["GET"],
  jsonResponse: z.object({
    things: z.array(
      z.object({
        thing_id: z.string(),
        name: z.string(),
        description: z.string(),
      }),
    ),
  }),
})((req, ctx) => {
  return ctx.json({ things: ctx.db.things })
})
</file>

<file path="routes/v1/messages/index.ts">
import { withRouteSpec } from "lib/middleware/with-winter-spec"
import { z } from "zod"

const MessageContentSchema = z.object({
  text: z.string(),
  type: z.literal("text"),
})

const UsageSchema = z.object({
  cache_creation_input_tokens: z.number(),
  cache_read_input_tokens: z.number(),
  input_tokens: z.number(),
  output_tokens: z.number(),
})

const MessageSchema = z.object({
  _request_id: z.string(),
  content: z.array(MessageContentSchema),
  id: z.string(),
  model: z.string(),
  role: z.literal("assistant"),
  stop_reason: z.literal("end_turn"),
  stop_sequence: z.null(),
  type: z.literal("message"),
  usage: UsageSchema,
})

export default withRouteSpec({
  methods: ["POST"],
  jsonBody: z.object({
    model: z.string(),
    max_tokens: z.number(),
    messages: z.array(
      z.object({
        role: z.string(),
        content: z.string(),
      }),
    ),
  }),
  jsonResponse: MessageSchema,
})((req, ctx) => {
  const { model, max_tokens, messages } = req.jsonBody

  const response: z.infer<typeof MessageSchema> = {
    _request_id: "req_019HyxDonkJQ1hi7nKaLkoMD",
    content: [{ text: "Hello world!", type: "text" }],
    id: "msg_01XEzaHf6udRSzDAS2ACBUwd",
    model: model,
    role: "assistant",
    stop_reason: "end_turn",
    stop_sequence: null,
    type: "message",
    usage: {
      cache_creation_input_tokens: 0,
      cache_read_input_tokens: 0,
      input_tokens: 0,
      output_tokens: 0,
    },
  }

  return ctx.json(response)
})
</file>

<file path="routes/health.ts">
import { withRouteSpec } from "lib/middleware/with-winter-spec"
import { z } from "zod"

export default withRouteSpec({
  methods: ["GET"],
  jsonResponse: z.object({ ok: z.boolean() }),
})((req, ctx) => {
  return ctx.json({ ok: true })
})
</file>

<file path="tests/fixtures/get-test-server.ts">
import { afterEach } from "bun:test"
import { tmpdir } from "node:os"
import defaultAxios from "redaxios"
import { startServer } from "./start-server"

interface TestFixture {
  url: string
  server: any
  axios: typeof defaultAxios
}

export const getTestServer = async (): Promise<TestFixture> => {
  const port = 3001 + Math.floor(Math.random() * 999)
  const testInstanceId = Math.random().toString(36).substring(2, 15)
  const testDbName = `testdb${testInstanceId}`

  const server = await startServer({
    port,
    testDbName,
  })

  const url = `http://127.0.0.1:${port}`
  const axios = defaultAxios.create({
    baseURL: url,
  })

  afterEach(async () => {
    await server.stop()
    // Here you might want to add logic to drop the test database
  })

  return {
    url,
    server,
    axios,
  }
}
</file>

<file path="tests/fixtures/normalizeForSnapshot.ts">
export function normalizeForSnapshot(obj: any): any {
  if (Array.isArray(obj)) {
    return obj.map(normalizeForSnapshot)
  }

  if (obj && typeof obj === "object") {
    const normalized: Record<string, any> = {}
    for (const [key, value] of Object.entries(obj)) {
      if (key.toLowerCase().includes("id")) {
        normalized[key] = "[id]"
      } else {
        normalized[key] = normalizeForSnapshot(value)
      }
    }
    return normalized
  }

  return obj
}
</file>

<file path="tests/fixtures/start-server.ts">
import {
  createFetchHandlerFromDir,
  createWinterSpecBundleFromDir,
} from "winterspec/adapters/node"
import { Request as EdgeRuntimeRequest } from "@edge-runtime/primitives"
import { join } from "node:path"
import os from "node:os"
import type { Middleware } from "winterspec"
import { createDatabase } from "lib/db/db-client"

export const startServer = async ({
  port,
  testDbName,
}: { port: number; testDbName: string }) => {
  const winterspecBundle = await createWinterSpecBundleFromDir(
    join(import.meta.dir, "../../routes"),
  )

  const db = createDatabase()

  const middleware: Middleware[] = [
    async (req: any, ctx: any, next: any) => {
      ;(ctx as any).db = db

      return next(req, ctx)
    },
  ]

  const server = Bun.serve({
    fetch: (bunReq) => {
      console.log(bunReq.url)
      const req = new EdgeRuntimeRequest(bunReq.url, {
        headers: bunReq.headers,
        method: bunReq.method,
        body: bunReq.body,
      })
      return winterspecBundle.makeRequest(req as any, {
        middleware,
      })
    },
    port,
  })

  return server
}
</file>

<file path="tests/routes/things/create.test.ts">
import { getTestServer } from "tests/fixtures/get-test-server"
import { test, expect } from "bun:test"

test("create a thing", async () => {
  const { axios } = await getTestServer()

  axios.post("/things/create", {
    name: "Thing1",
    description: "Thing1 Description",
  })

  const { data } = await axios.get("/things/list")

  expect(data.things).toHaveLength(1)
})
</file>

<file path="tests/routes/health.test.ts">
import { it, expect } from "bun:test"
import { getTestServer } from "tests/fixtures/get-test-server"

it("GET /health should return ok", async () => {
  const { axios } = await getTestServer()
  const res = await axios.get("/health")
  expect(res.status).toBe(200)
  expect(res.data).toEqual({ ok: true })
})
</file>

<file path="tests/usage/usage1-anthropic-sdk.test.ts">
import { test, expect } from "bun:test"
import Anthropic from "@anthropic-ai/sdk"
import { getTestServer } from "tests/fixtures/get-test-server"
import { normalizeForSnapshot } from "tests/fixtures/normalizeForSnapshot"

test("basic anthropic sdk usage", async () => {
  const { url } = await getTestServer()
  const anthropic = new Anthropic({
    apiKey: "fake-anthropic-api-key",
    baseURL: url,
  })

  const message = await anthropic.messages.create({
    model: "claude-3-5-haiku-20241022",
    max_tokens: 1024,
    messages: [
      {
        role: "user",
        content: "Say hello world!",
      },
    ],
  })

  expect(normalizeForSnapshot(message)).toMatchInlineSnapshot(`
{
  "content": [
    {
      "text": "Hello world!",
      "type": "text",
    },
  ],
  "id": "[id]",
  "model": "claude-3-5-haiku-20241022",
  "role": "assistant",
  "stop_reason": "end_turn",
  "stop_sequence": null,
  "type": "message",
  "usage": {
    "cache_creation_input_tokens": 0,
    "cache_read_input_tokens": 0,
    "input_tokens": 0,
    "output_tokens": 0,
  },
}
`)
})
</file>

<file path=".gitignore">
# Based on https://raw.githubusercontent.com/github/gitignore/main/Node.gitignore

# Logs

logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Caches

.cache

# Diagnostic reports (https://nodejs.org/api/report.html)

report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# Runtime data

pids
_.pid
_.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover

lib-cov

# Coverage directory used by tools like istanbul

coverage
*.lcov

# nyc test coverage

.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)

.grunt

# Bower dependency directory (https://bower.io/)

bower_components

# node-waf configuration

.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)

build/Release

# Dependency directories

node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)

web_modules/

# TypeScript cache

*.tsbuildinfo

# Optional npm cache directory

.npm

# Optional eslint cache

.eslintcache

# Optional stylelint cache

.stylelintcache

# Microbundle cache

.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history

.node_repl_history

# Output of 'npm pack'

*.tgz

# Yarn Integrity file

.yarn-integrity

# dotenv environment variable files

.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)

.parcel-cache

# Next.js build output

.next
out

# Nuxt.js build / generate output

.nuxt
dist

# Gatsby files

# Comment in the public line in if your project uses Gatsby and not Next.js

# https://nextjs.org/blog/next-9-1#public-directory-support

# public

# vuepress build output

.vuepress/dist

# vuepress v2.x temp and cache directory

.temp

# Docusaurus cache and generated files

.docusaurus

# Serverless directories

.serverless/

# FuseBox cache

.fusebox/

# DynamoDB Local files

.dynamodb/

# TernJS port file

.tern-port

# Stores VSCode versions used for testing VSCode extensions

.vscode-test

# yarn v2

.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store

.vscode
.winterspec
.aider*
</file>

<file path="biome.json">
{
  "$schema": "https://biomejs.dev/schemas/1.7.3/schema.json",
  "organizeImports": {
    "enabled": true
  },
  "formatter": {
    "enabled": true,
    "indentStyle": "space"
  },
  "files": {
    "ignore": ["cosmos-export", "dist", "package.json"]
  },
  "javascript": {
    "formatter": {
      "jsxQuoteStyle": "double",
      "quoteProperties": "asNeeded",
      "trailingCommas": "all",
      "semicolons": "asNeeded",
      "arrowParentheses": "always",
      "bracketSpacing": true,
      "bracketSameLine": false
    }
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true,
      "suspicious": {
        "noExplicitAny": "off"
      },
      "complexity": {
        "noBannedTypes": "off"
      },
      "style": {
        "noNonNullAssertion": "off",
        "useFilenamingConvention": {
          "level": "error",
          "options": {
            "strictCase": true,
            "requireAscii": true,
            "filenameCases": ["kebab-case", "export"]
          }
        }
      }
    }
  }
}
</file>

<file path="next-env.d.ts">
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.
</file>

<file path="package.json">
{
  "name": "@tscircuit/fake-anthropic",
  "main": "dist/bundle.js",
  "version": "0.0.4",
  "type": "module",
  "devDependencies": {
    "@anthropic-ai/sdk": "^0.33.1",
    "@biomejs/biome": "^1.8.3",
    "@types/bun": "^1.1.16",
    "@types/react": "18.3.4",
    "next": "^14.2.5",
    "redaxios": "^0.5.1"
  },
  "peerDependencies": {
    "typescript": "^5.0.0"
  },
  "dependencies": {
    "immer": "^10.1.1",
    "winterspec": "^0.0.86",
    "zod": "^3.23.8",
    "zustand": "^4.5.5",
    "zustand-hoist": "^2.0.1"
  },
  "scripts": {
    "start": "bun run dev",
    "dev": "winterspec dev",
    "build": "winterspec bundle -o dist/bundle.js",
    "next:dev": "next dev"
  }
}
</file>

<file path="README.md">
# @tscircuit/fake-anthropic

`fake-anthropic` is a library that starts a server that can substitute for the
production Anthropic API. It's used for testing anthropic without making any
calls the production API.

You can start the `fake-anthropic` server like this:

## Usage with Bun

```tsx
import fakeAnthropicWinterspecBundle from "@tscircuit/fake-anthropic"

// Start a server with Bun
Bun.serve({
  port: 3030,
  fetch: (req) => {
    return fakeAnthopicWinterspecBundle.makeRequest(req)
  },
})
```

## Usage with NodeJS

```tsx
import http from "node:http"
import { getNodeHandler } from "winterspec/adapters/node"

const nodeHandler = getNodeHandler(fakeJlcpcbBundle, {
  port,
})

const server = http.createServer((req, res) => {
  nodeHandler(req, res)
})

server.listen(3000)
```

## Usage in Bun Test Fixtures

Many times, you'll want to create a test fixture that sets up your fake
anthropic server for usage with the Anthropic SDK.

```tsx
import fakeAnthropicWinterspecBundle from "@tscircuit/fake-anthropic/dist/bundle"
import { afterEach } from "bun:test"

export const getTestAnthropicServer = async () => {
  const port = 3000
  process.env.ANTHROPIC_API_KEY = "fake-anthropic-api-key"
  process.env.ANTHROPIC_BASE_URL = `http://localhost:${port}`

  const server = Bun.serve({
    port,
    fetch: (req) => {
      return fakeAnthopicWinterspecBundle.fetch(req)
    },
  })

  afterEach(() => {
    server.close()
  })

  return { anthropicBaseUrl: `http://localhost:${port}` }
}

// sometest.test.ts

test("my anthropic test", () => {
  await getTestAnthropicServer()

  const anthropic = new Anthropic({
    apiKey: process.env.ANTHROPIC_API_KEY,
    baseURL: process.env.ANTHROPIC_BASE_URL,
  })
})
```
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    // Enable latest features
    "lib": [
      "ESNext",
      "DOM"
    ],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "preserve",
    "allowJs": true,
    "baseUrl": ".",
    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,
    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false,
    "incremental": true,
    "esModuleInterop": true,
    "resolveJsonModule": true
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path="winterspec.config.ts">
import { defineConfig } from "winterspec"

export default defineConfig({
  routesDirectory: "./routes",
  platform: "node",
})
</file>

</files>
